

<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=51376&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />

<title>sync.Map | Golang for all</title>




  






  
  
    
  








  



<meta name="description" content="Let&rsquo;s take a look at sync.Map usage and its source code.
">


<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:51376/en/post/sync-map.html">
<meta property="og:title" content="sync.Map | Golang for all">
<meta property="og:description" content="Let&rsquo;s take a look at sync.Map usage and its source code.
">
<meta property="og:image" content="http://localhost:51376/en/post/sync-map/dvoe.svg">
<meta property="og:site_name" content="Golang for all">
<meta property="og:locale" content="en">

  
    <meta property="article:published_time" content="2020-05-02T09:00:00&#43;03:00">
  
  
    <meta property="article:modified_time" content="2020-05-02T09:00:00&#43;03:00">
  
  
    
      <meta property="article:tag" content="Sync.map">
    
      <meta property="article:tag" content="Map">
    
      <meta property="article:tag" content="Concurrency">
    
  



<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:url" content="http://localhost:51376/en/post/sync-map.html">
<meta name="twitter:title" content="sync.Map | Golang for all">
<meta name="twitter:description" content="Let&rsquo;s take a look at sync.Map usage and its source code.
">
<meta name="twitter:image" content="http://localhost:51376/en/post/sync-map/dvoe.svg">



<link rel="canonical" href="http://localhost:51376/en/post/sync-map.html">



  <link rel="alternate" hreflang="ru" href="http://localhost:51376/ru/post/sync-map.html">


<meta name="yandex-verification" content="10233a4b32f4dc29" />
<meta name="yandex-verification" content="cfa4be404c1af368" />

<link rel="icon" type="image/png" sizes="93x93" href="/gophereye.png"/>
<link rel="icon" type="image/png" sizes="32x32" href="/gophereye32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/gophereye16x16.png">


    <link rel="stylesheet" href="/css/main.css">


      <script src="/js/main.js"></script>


<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.4.6/css/flag-icon.min.css" integrity="sha256-YjcCvXkdRVOucibC9I4mBS41lXPrWfqY2BnpskhZPnw=" crossorigin="anonymous" />


</head>
<body>
<div class="container">
    <nav class="navbar navbar-expand-lg navbar-light" style="padding-bottom: 0;">
        <div class="container">
            <a class="navbar-brand" href="/en/" style="padding-bottom: 0">
                <img src="/verh.svg" alt="gopher eyes" style="height: 50px;"/>
            </a>

            <button class="navbar-toggler" type="button"
                    data-toggle="collapse"
                    data-target="#navbarResponsive"
                    aria-controls="navbarResponsive"
                    aria-expanded="false"
                    aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <a href="/en/" style="color:#000;"><span class="gopherchat">Golang for all</span></a>
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item active">
                        <a class="nav-link" href="/en/about.html">About</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </nav>
</div>
<div class="bg-light">&nbsp;</div>

<div class="container">
    
<div class="col-lg-12">
    
    <h1 class="mt-4">sync.Map</h1>

    
    <p>


  May 2, 2020



            <a href="/tags/sync.map/" class="badge">Sync.map</a>
            <a href="/tags/map/" class="badge">Map</a>
            <a href="/tags/concurrency/" class="badge">Concurrency</a>
    </p>

    <hr/>

    
    
    
    <div class="container">
        <div class="row mx-0 my-0">
            <div class="col-md-8">
                <img class="img-fluid rounded"
                     style="max-height: 400px;"
                     src="/en/post/sync-map/dvoe.svg"
                     alt="sync.Map"/>
            </div>
            <div class="col-md-4">
                
                
                <nav id="toc">
                    <h5>Contents</h5>
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#interface">Interface</a></li>
    <li><a href="#sources">Sources</a></li>
    <li><a href="#reading">Reading</a></li>
    <li><a href="#updating">Updating</a></li>
    <li><a href="#iterating">Iterating</a></li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
                </nav>
                
            </div>
        </div>
    </div>
    <hr>
    
    

    <div id="post-content">
    <p>Let&rsquo;s take a look at <code>sync.Map</code> usage and its source code.</p>
<h2 id="interface">Interface</h2>
<p>The following methods are available to work with <code>sync.Map</code>:</p>
<ul>
<li><code>Load(key interface{}) (value interface{}, ok bool)</code></li>
<li><code>Store(key, value interface{})</code></li>
<li><code>Delete(key interface{})</code></li>
<li><code>Range(f func(key, value interface{}) bool)</code></li>
<li><code>LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)</code></li>
</ul>
<p>This covers every map use case — insert, read, delete, and iteration. There is also the <code>LoadOrStore</code> bonus method, which allows setting a value by key if the value is not set before.</p>
<p>To perform iteration, there is <code>Range</code>, which receives a function that is called on every map element. If that function returns <code>false</code>, iteration will be stopped.</p>
<p>When seeing the <code>sync.Map</code> name, one might imagine that <code>sync.Map</code> is a simple map with some <code>sync</code> package features. But actually <code>sync.Map</code> is much more complex. Let&rsquo;s dive into the source code and find out how it works.</p>
<h2 id="sources">Sources</h2>
<p>The <code>sync.Map</code> struct looks as below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">read</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Value</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dirty</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#f92672">*</span><span style="color:#a6e22e">entry</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">misses</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">readOnly</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>       <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#f92672">*</span><span style="color:#a6e22e">entry</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">amended</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>read</code> — a pointer to a <code>readOnly</code> struct. This struct stores part of the data that is used to read data by key or to check that there is data behind that key. There are no inserts into <code>read</code>, that&rsquo;s why no mutex is used when accessing <code>read</code>.</p>
<p><code>dirty</code> — a map that stores the other part of elements. It is generally used to place new elements and for reading too. In that case, the <code>mu</code> mutex is used when <code>dirty</code> is accessed.</p>
<p>So <code>sync.Map</code> has two internal maps (<code>read</code> and <code>dirty</code>). By using one map only for reading and a second for writing, <code>sync.Map</code> tries to avoid using a mutex when possible. Let&rsquo;s take a look at <code>sync.Map</code> operations.</p>
<h2 id="reading">Reading</h2>
<p>First, <code>read</code> is accessed to check if there is data behind the key. If it is — the data is returned. This is the simplest scenario — to return data from <code>read</code>.</p>
<p>Then <code>dirty</code> is searched — the <code>mu</code> mutex is activated beforehand. <code>misses</code> — a counter of accesses to <code>dirty</code> — is incremented. An important thing — if that counter&rsquo;s value is more than the number of elements in <code>dirty</code>, elements in <code>dirty</code> will be copied to <code>read</code>, and the counter will be reset. The copying will happen right after <code>dirty</code> access — <code>mu</code> is activated at that moment.</p>
<p>To avoid extra <code>dirty</code> access, there is an <code>amended</code> field in the <code>readOnly</code> struct (which is <code>read</code>). <code>amended = true</code> means there is a non-empty <code>dirty</code> map in <code>sync.Map</code>.</p>
<p>So, reading from <code>sync.Map</code> is most effective when read-only. In this case, this reading is equal to simple map (without mutex) reading. If there is only reading from a large map set up beforehand, <code>sync.Map</code> is good in that case.</p>
<h2 id="updating">Updating</h2>
<p>First, there is a check against <code>read</code> — if there is data behind the key. If yes — the value is updated by <code>atomic.CompareAndSwap</code>.</p>
<p>If there is no data read by the key, the same reading is performed against <code>dirty</code>. If <code>dirty</code> is not initialized — it will be.</p>
<p>So, updating an already existent key is simple, but adding data with a new key is complex.</p>
<h2 id="iterating">Iterating</h2>
<p>Before iterating, <code>dirty</code> is copied into <code>read</code>, if <code>dirty</code> stores anything. This is done with the <code>mu</code> mutex activated.</p>
<p>Next, there is <code>read</code> iteration — simple map iteration.</p>
<h2 id="summary">Summary</h2>
<p><code>sync.Map</code> is a complex struct, generally consisting of two maps — one for reading and one for new elements. <code>sync.Map</code> is not only close to <code>map+sync.RWMutex</code> on speed metrics, but can also be the best in the read-only case. When there is both reading and updating, <code>sync.Map</code> will have elements in both <code>read</code> and <code>dirty</code>. In that case, <code>sync.Map</code> performs worse than <code>map+sync.RWMutex</code> because of reading from two internal maps. Also, there is a counter that needs to be updated when accessing <code>dirty</code>.</p>
    
  <div>
    <div>Tags:</div>
    <ul>
        <li><a href="/tags/sync.map/">Sync.map</a></li>
        <li><a href="/tags/map/">Map</a></li>
        <li><a href="/tags/concurrency/">Concurrency</a></li>
    </ul>
  </div>

    </div>
    
<div id="article-quiz" class="mt-5 mb-5" data-quiz-lang="en">
  <hr class="mb-4">
  <h3 class="mb-4">Test Your Knowledge</h3>
  
  <form id="quiz-form" data-quiz-data="{&#34;questions&#34;:[{&#34;answers&#34;:[{&#34;correct&#34;:true,&#34;text&#34;:&#34;read - for reading data&#34;},{&#34;correct&#34;:true,&#34;text&#34;:&#34;dirty - for new elements and writing&#34;},{&#34;correct&#34;:false,&#34;text&#34;:&#34;cache - for caching&#34;}],&#34;question&#34;:&#34;What are the two internal maps in `sync.Map`?&#34;,&#34;type&#34;:&#34;multiple-choice&#34;},{&#34;answers&#34;:[{&#34;correct&#34;:true,&#34;text&#34;:&#34;Reading from &#39;read&#39; doesn&#39;t require a mutex&#34;},{&#34;correct&#34;:false,&#34;text&#34;:&#34;It uses less memory&#34;},{&#34;correct&#34;:false,&#34;text&#34;:&#34;It&#39;s faster than regular maps&#34;}],&#34;question&#34;:&#34;Why is `sync.Map` most effective for read-only scenarios?&#34;,&#34;type&#34;:&#34;single-choice&#34;},{&#34;answers&#34;:[{&#34;correct&#34;:true,&#34;text&#34;:&#34;Elements from &#39;dirty&#39; are copied to &#39;read&#39; and counter is reset&#34;},{&#34;correct&#34;:false,&#34;text&#34;:&#34;The map is cleared&#34;},{&#34;correct&#34;:false,&#34;text&#34;:&#34;An error is thrown&#34;}],&#34;question&#34;:&#34;What happens when the &#39;misses&#39; counter exceeds the number of elements in &#39;dirty&#39;?&#34;,&#34;type&#34;:&#34;single-choice&#34;},{&#34;answers&#34;:[{&#34;correct&#34;:true,&#34;text&#34;:&#34;When there is both reading and updating&#34;},{&#34;correct&#34;:false,&#34;text&#34;:&#34;When there is only reading&#34;},{&#34;correct&#34;:false,&#34;text&#34;:&#34;When the map is empty&#34;}],&#34;question&#34;:&#34;When does `sync.Map` perform worse than `map&#43;sync.RWMutex`?&#34;,&#34;type&#34;:&#34;single-choice&#34;}]}">
    
    <div class="quiz-question mb-4 p-3 border rounded" data-question-index="0">
      <h5 class="mb-3">1. What are the two internal maps in `sync.Map`?</h5>
      
      
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="checkbox" 
                 name="question-0" 
                 value="0"
                 id="q0-a0">
          <label class="form-check-label" for="q0-a0">
            read - for reading data
          </label>
        </div>
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="checkbox" 
                 name="question-0" 
                 value="1"
                 id="q0-a1">
          <label class="form-check-label" for="q0-a1">
            dirty - for new elements and writing
          </label>
        </div>
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="checkbox" 
                 name="question-0" 
                 value="2"
                 id="q0-a2">
          <label class="form-check-label" for="q0-a2">
            cache - for caching
          </label>
        </div>
        
      
      
      <div class="quiz-feedback mt-2" style="display: none;"></div>
    </div>
    
    <div class="quiz-question mb-4 p-3 border rounded" data-question-index="1">
      <h5 class="mb-3">2. Why is `sync.Map` most effective for read-only scenarios?</h5>
      
      
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-1" 
                 value="0"
                 id="q1-a0">
          <label class="form-check-label" for="q1-a0">
            Reading from &#39;read&#39; doesn&#39;t require a mutex
          </label>
        </div>
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-1" 
                 value="1"
                 id="q1-a1">
          <label class="form-check-label" for="q1-a1">
            It uses less memory
          </label>
        </div>
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-1" 
                 value="2"
                 id="q1-a2">
          <label class="form-check-label" for="q1-a2">
            It&#39;s faster than regular maps
          </label>
        </div>
        
      
      
      <div class="quiz-feedback mt-2" style="display: none;"></div>
    </div>
    
    <div class="quiz-question mb-4 p-3 border rounded" data-question-index="2">
      <h5 class="mb-3">3. What happens when the &#39;misses&#39; counter exceeds the number of elements in &#39;dirty&#39;?</h5>
      
      
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-2" 
                 value="0"
                 id="q2-a0">
          <label class="form-check-label" for="q2-a0">
            Elements from &#39;dirty&#39; are copied to &#39;read&#39; and counter is reset
          </label>
        </div>
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-2" 
                 value="1"
                 id="q2-a1">
          <label class="form-check-label" for="q2-a1">
            The map is cleared
          </label>
        </div>
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-2" 
                 value="2"
                 id="q2-a2">
          <label class="form-check-label" for="q2-a2">
            An error is thrown
          </label>
        </div>
        
      
      
      <div class="quiz-feedback mt-2" style="display: none;"></div>
    </div>
    
    <div class="quiz-question mb-4 p-3 border rounded" data-question-index="3">
      <h5 class="mb-3">4. When does `sync.Map` perform worse than `map&#43;sync.RWMutex`?</h5>
      
      
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-3" 
                 value="0"
                 id="q3-a0">
          <label class="form-check-label" for="q3-a0">
            When there is both reading and updating
          </label>
        </div>
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-3" 
                 value="1"
                 id="q3-a1">
          <label class="form-check-label" for="q3-a1">
            When there is only reading
          </label>
        </div>
        
        <div class="form-check mb-2">
          <input class="form-check-input" type="radio" 
                 name="question-3" 
                 value="2"
                 id="q3-a2">
          <label class="form-check-label" for="q3-a2">
            When the map is empty
          </label>
        </div>
        
      
      
      <div class="quiz-feedback mt-2" style="display: none;"></div>
    </div>
    
    
    <button type="button" class="btn btn-primary" id="check-answers">
      Check Answers
    </button>
    <button type="button" class="btn btn-secondary ml-2" id="reset-quiz" style="display: none;">
      Reset
    </button>
  </form>
  
  <div id="quiz-results" class="mt-4" style="display: none;">
    <div class="alert" role="alert"></div>
  </div>
</div>

<script>
(function() {
  try {
    const quizContainer = document.getElementById('article-quiz');
    const form = document.getElementById('quiz-form');
    const checkBtn = document.getElementById('check-answers');
    const resetBtn = document.getElementById('reset-quiz');
    const resultsDiv = document.getElementById('quiz-results');
    
    if (!quizContainer || !form || !checkBtn) {
      console.error('Quiz initialization failed: missing elements', {
        quizContainer: !!quizContainer,
        form: !!form,
        checkBtn: !!checkBtn
      });
      return;
    }
    
    const lang = quizContainer.getAttribute('data-quiz-lang') || 'en';
    const quizDataRaw = form.getAttribute('data-quiz-data');
    
    if (!quizDataRaw) {
      console.error('Quiz data not found in data attribute');
      return;
    }
    
    let quizData;
    try {
      quizData = JSON.parse(quizDataRaw);
    } catch (e) {
      console.error('Failed to parse quiz data:', e, quizDataRaw);
      return;
    }
    
    if (!quizData || !quizData.questions || !Array.isArray(quizData.questions)) {
      console.error('Invalid quiz data structure:', quizData);
      return;
    }
    
    
    console.log('Quiz data loaded:', quizData);
  
    function arraysEqual(a, b) {
      if (!a || !b) return false;
      if (a.length !== b.length) return false;
      const sortedA = [...a].sort();
      const sortedB = [...b].sort();
      return sortedA.every((val, i) => val === sortedB[i]);
    }
    
    checkBtn.addEventListener('click', function() {
    if (!quizData.questions || !Array.isArray(quizData.questions)) {
      console.error('Invalid quiz data structure');
      return;
    }
    
    let correctCount = 0;
    let totalQuestions = quizData.questions.length;
    
    quizData.questions.forEach((question, qIndex) => {
      const questionDiv = form.querySelector(`[data-question-index="${qIndex}"]`);
      if (!questionDiv) {
        console.error('Question div not found for index:', qIndex);
        return;
      }
      
      const feedbackDiv = questionDiv.querySelector('.quiz-feedback');
      if (!feedbackDiv) {
        console.error('Feedback div not found for question:', qIndex);
        return;
      }
      
      if (question.type === 'multiple-choice' || question.type === 'single-choice') {
        if (!question.answers || !Array.isArray(question.answers)) {
          console.error('Invalid answers for question:', qIndex);
          return;
        }
        
        const inputs = questionDiv.querySelectorAll(`input[name="question-${qIndex}"]`);
        const selectedAnswers = Array.from(inputs)
          .filter(input => input.checked)
          .map(input => parseInt(input.value));
        
        const correctAnswers = question.answers
          .map((answer, index) => answer.correct === true ? index : -1)
          .filter(index => index !== -1);
        
        const isCorrect = arraysEqual(selectedAnswers, correctAnswers);
        
        if (isCorrect) {
          correctCount++;
          feedbackDiv.innerHTML = '<span class="text-success">✓ ' + (lang === 'ru' ? 'Правильно!' : 'Correct!') + '</span>';
          feedbackDiv.style.display = 'block';
          inputs.forEach(input => {
            const answerIndex = parseInt(input.value);
            const answer = question.answers[answerIndex];
            if (!answer) return;
            
            if (input.checked && answer.correct === true) {
              input.parentElement.classList.add('text-success');
            } else if (input.checked && answer.correct !== true) {
              input.parentElement.classList.add('text-danger');
            } else if (!input.checked && answer.correct === true) {
              input.parentElement.classList.add('text-warning');
            }
          });
        } else {
          feedbackDiv.innerHTML = '<span class="text-danger">✗ ' + (lang === 'ru' ? 'Неправильно' : 'Incorrect') + '</span>';
          feedbackDiv.style.display = 'block';
          inputs.forEach(input => {
            const answerIndex = parseInt(input.value);
            const answer = question.answers[answerIndex];
            if (!answer) return;
            
            if (input.checked && answer.correct !== true) {
              input.parentElement.classList.add('text-danger');
            } else if (!input.checked && answer.correct === true) {
              input.parentElement.classList.add('text-warning');
            }
          });
        }
      } else if (question.type === 'text') {
        const textarea = questionDiv.querySelector('textarea');
        const correctAnswerDiv = questionDiv.querySelector('[data-correct-answer]');
        
        if (!textarea || !question.correct_answer) {
          console.error('Invalid text question:', qIndex);
          return;
        }
        
        if (textarea.value.trim().toLowerCase() === question.correct_answer.toLowerCase()) {
          correctCount++;
          feedbackDiv.innerHTML = '<span class="text-success">✓ ' + (lang === 'ru' ? 'Правильно!' : 'Correct!') + '</span>';
          feedbackDiv.style.display = 'block';
        } else {
          feedbackDiv.innerHTML = '<span class="text-danger">✗ ' + (lang === 'ru' ? 'Неправильно' : 'Incorrect') + '</span>';
          feedbackDiv.style.display = 'block';
          if (correctAnswerDiv) {
            correctAnswerDiv.style.display = 'block';
          }
        }
      }
    });
    
    const percentage = Math.round((correctCount / totalQuestions) * 100);
    const alertClass = percentage >= 70 ? 'alert-success' : percentage >= 50 ? 'alert-warning' : 'alert-danger';
    const message = (lang === 'ru' ? 'Вы ответили правильно на ' : 'You got ') + 
                   correctCount + (lang === 'ru' ? ' из ' : ' out of ') + 
                   totalQuestions + (lang === 'ru' ? ' вопросов (' : ' questions (') + 
                   percentage + '%)';
    
    const alertElement = resultsDiv.querySelector('.alert');
    if (alertElement) {
      alertElement.className = 'alert ' + alertClass;
      alertElement.textContent = message;
    }
      resultsDiv.style.display = 'block';
      checkBtn.style.display = 'none';
      if (resetBtn) {
        resetBtn.style.display = 'inline-block';
      }
    });
    
    if (resetBtn) {
      resetBtn.addEventListener('click', function() {
        form.reset();
        form.querySelectorAll('.quiz-feedback').forEach(el => el.style.display = 'none');
        form.querySelectorAll('.text-success, .text-danger, .text-warning').forEach(el => {
          el.classList.remove('text-success', 'text-danger', 'text-warning');
        });
        form.querySelectorAll('[data-correct-answer]').forEach(el => el.style.display = 'none');
        resultsDiv.style.display = 'none';
        checkBtn.style.display = 'inline-block';
        resetBtn.style.display = 'none';
      });
    }
  } catch (error) {
    console.error('Quiz script error:', error);
  }
})();
</script>



    
    <hr class="mt-5 mb-4">
    <h3 class="mb-4">Related Articles</h3>
    <div class="row">
      <div class="col-md-6 mb-4">
        <div class="card h-100 bg-light rounded" style="border: none;">
          <div class="card-body">
            <span style="color: #aaa; font-size: 0.9em;">


  April 2, 2020


</span>
            <h4 class="card-title mt-2">
              <a href="/en/post/golang-data-handling-concurrent-programs.html" style="text-decoration: none; color: inherit;">Data handling in concurrent programs</a>
            </h4>
            
            
            
            <a href="/en/post/golang-data-handling-concurrent-programs.html">
              <img class="card-img-top mb-3 rounded"
                   src="/en/post/golang-data-handling-concurrent-programs/kanat.svg"
                   style="max-height: 200px;"
                   alt="Data handling in concurrent programs"/>
            </a>
            
            
            <p class="card-text"><p>In Go, we have goroutines functionality out of the box. We can run code in parallel. However, in our parallel running code we can work with shared variables, and it is not clear how exactly Go handles such situations.</p></p>
            
            <a href="/en/post/golang-data-handling-concurrent-programs.html" class="btn btn-primary btn-sm">Read More →</a>
                  <a href="/tags/map/" class="badge">Map</a>
                  <a href="/tags/sources/" class="badge">Sources</a>
          </div>
        </div>
      </div>
      <div class="col-md-6 mb-4">
        <div class="card h-100 bg-light rounded" style="border: none;">
          <div class="card-body">
            <span style="color: #aaa; font-size: 0.9em;">


  April 2, 2020


</span>
            <h4 class="card-title mt-2">
              <a href="/en/post/map-principles-golang.html" style="text-decoration: none; color: inherit;">Principles of map type in GO</a>
            </h4>
            
            
            
            <a href="/en/post/map-principles-golang.html">
              <img class="card-img-top mb-3 rounded"
                   src="/en/post/map-principles-golang/map.svg"
                   style="max-height: 200px;"
                   alt="Principles of map type in GO"/>
            </a>
            
            
            <p class="card-text"><p>The map programming interface in Go is described in the Go blog. We just need to recall that a map is a key-value storage and it should retrieve values by key as fast as possible.</p></p>
            
            <a href="/en/post/map-principles-golang.html" class="btn btn-primary btn-sm">Read More →</a>
                  <a href="/tags/map/" class="badge">Map</a>
                  <a href="/tags/sources/" class="badge">Sources</a>
          </div>
        </div>
      </div>
    </div>


    <script defer src="/discuss.js"></script>
    <div id="discuss"></div>
</div>

</div>

<div class="bg-light">&nbsp;</div>

<footer>
    <div class="container " style="padding-top: 0; padding-bottom: 10px;">
    <div class="container">
        <img src="/niz.svg" alt="gopher legs" style="height: 50px; vertical-align: top;"/>
        <div style="text-align: right; vertical-align: top; display: inline-block;">
            
            &nbsp;
            &nbsp;
            &nbsp;
            
            
            <a href='/ru/post/sync-map.html'>
            <span class="flag-icon flag-icon-ru"></span>
            </a>
            
        </div>

    </div>
</div>

</footer>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script defer src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

</body>
</html>
