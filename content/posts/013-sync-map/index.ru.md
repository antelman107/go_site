+++
title = 'sync.Map'
date = 2020-05-02T09:00:00+03:00
draft = false
tags = ['sync.map', 'map', 'concurrency']
featured_image = 'dvoe.svg'
url = '/ru/post/sync-map.html'

[quiz]
  [[quiz.questions]]
    question = "Какие две внутренние карты есть в `sync.Map`?"
    type = "multiple-choice"
    [[quiz.questions.answers]]
      text = "read - для чтения данных"
      correct = true
    [[quiz.questions.answers]]
      text = "dirty - для новых элементов и записи"
      correct = true
    [[quiz.questions.answers]]
      text = "cache - для кэширования"
      correct = false
  
  [[quiz.questions]]
    question = "Почему `sync.Map` наиболее эффективен для сценариев только чтения?"
    type = "single-choice"
    [[quiz.questions.answers]]
      text = "Чтение из 'read' не требует мьютекса"
      correct = true
    [[quiz.questions.answers]]
      text = "Он использует меньше памяти"
      correct = false
    [[quiz.questions.answers]]
      text = "Он быстрее обычных карт"
      correct = false
  
  [[quiz.questions]]
    question = "Что происходит, когда счетчик 'misses' превышает количество элементов в 'dirty'?"
    type = "single-choice"
    [[quiz.questions.answers]]
      text = "Элементы из 'dirty' копируются в 'read', и счетчик сбрасывается"
      correct = true
    [[quiz.questions.answers]]
      text = "Карта очищается"
      correct = false
    [[quiz.questions.answers]]
      text = "Выбрасывается ошибка"
      correct = false
  
  [[quiz.questions]]
    question = "Когда `sync.Map` работает хуже, чем `map+sync.RWMutex`?"
    type = "single-choice"
    [[quiz.questions.answers]]
      text = "Когда есть и чтение, и обновление"
      correct = true
    [[quiz.questions.answers]]
      text = "Когда есть только чтение"
      correct = false
    [[quiz.questions.answers]]
      text = "Когда карта пуста"
      correct = false
+++

Давайте рассмотрим использование `sync.Map` и его исходный код.

<!--more-->

## Интерфейс

Следующие методы доступны для работы с `sync.Map`:

- `Load(key interface{}) (value interface{}, ok bool)`
- `Store(key, value interface{})`
- `Delete(key interface{})`
- `Range(f func(key, value interface{}) bool)`
- `LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)`

Это покрывает все случаи использования карты — вставка, чтение, удаление и итерация. Также есть бонусный метод `LoadOrStore`, который позволяет установить значение по ключу, если значение не было установлено ранее.

Для выполнения итерации есть `Range`, который получает функцию, вызываемую для каждого элемента карты. Если эта функция возвращает `false`, итерация будет остановлена.

При виде названия `sync.Map` можно подумать, что `sync.Map` — это простая карта с некоторыми функциями пакета `sync`. Но на самом деле `sync.Map` намного сложнее. Давайте погрузимся в исходный код и выясним, как это работает.

## Исходный код

Структура `sync.Map` выглядит следующим образом:

```go
type Map struct {
	mu sync.Mutex

	read atomic.Value
	dirty map[interface{}]*entry
	misses int
}

type readOnly struct {
	m       map[interface{}]*entry
	amended bool
}
```

`read` — указатель на структуру `readOnly`. Эта структура хранит часть данных, которые используются для чтения данных по ключу или для проверки наличия данных за этим ключом. В `read` нет вставок, поэтому при доступе к `read` не используется мьютекс.

`dirty` — карта, которая хранит другую часть элементов. Она обычно используется для размещения новых элементов и также для чтения. В этом случае мьютекс `mu` используется при доступе к `dirty`.

Таким образом, `sync.Map` имеет две внутренние карты (`read` и `dirty`). Используя одну карту только для чтения, а вторую для записи, `sync.Map` пытается избежать использования мьютекса, когда это возможно. Давайте рассмотрим операции `sync.Map`.

## Чтение

Сначала обращаются к `read`, чтобы проверить, есть ли данные за ключом. Если они есть — данные возвращаются. Это самый простой сценарий — вернуть данные из `read`.

Затем выполняется поиск в `dirty` — мьютекс `mu` активируется заранее. `misses` — счетчик обращений к `dirty` — увеличивается. Важная деталь — если значение этого счетчика больше количества элементов в `dirty`, элементы из `dirty` будут скопированы в `read`, и счетчик будет сброшен. Копирование произойдет сразу после доступа к `dirty` — в этот момент активируется `mu`.

Чтобы избежать лишнего доступа к `dirty`, в структуре `readOnly` (которая является `read`) есть поле `amended`. `amended = true` означает, что в `sync.Map` есть непустая карта `dirty`.

Таким образом, чтение из `sync.Map` наиболее эффективно, когда оно только для чтения. В этом случае это чтение равно простому чтению карты (без мьютекса). Если есть только чтение из большой карты, настроенной заранее, `sync.Map` хорошо подходит для этого случая.

## Обновление

Сначала выполняется проверка `read` — есть ли данные за ключом. Если да — значение обновляется с помощью `atomic.CompareAndSwap`.

Если данных, прочитанных по ключу, нет, выполняется то же чтение в `dirty`. Если `dirty` не инициализирована — она будет инициализирована.

Таким образом, обновление уже существующего ключа простое, но добавление данных с новым ключом сложное.

## Итерация

Перед итерацией `dirty` копируется в `read`, если `dirty` что-то хранит. Это делается с активированным мьютексом `mu`.

Затем выполняется итерация по `read` — простая итерация по карте.

## Резюме

`sync.Map` — это сложная структура, состоящая в основном из двух карт — одной для чтения и одной для новых элементов. `sync.Map` не только близок к `map+sync.RWMutex` по показателям скорости, но также может быть лучшим в случае только чтения. Когда есть и чтение, и обновление, `sync.Map` будет иметь элементы как в `read`, так и в `dirty`. В этом случае `sync.Map` работает хуже, чем `map+sync.RWMutex`, из-за чтения из двух внутренних карт. Кроме того, есть счетчик, который нужно обновлять при доступе к `dirty`.

